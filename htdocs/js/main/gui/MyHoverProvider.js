import { Klass, Interface } from "../../compiler/types/Class.js";
import { Method, Attribute, PrimitiveType } from "../../compiler/types/Types.js";
import { getDeclarationAsString, getGenericParameterDefinition } from "../../compiler/types/DeclarationHelper.js";
import { InterpreterState } from "../../interpreter/Interpreter.js";
export class MyHoverProvider {
    constructor(editor) {
        this.editor = editor;
    }
    provideHover(model, position, token) {
        var _a, _b;
        let selection = this.editor.editor.getSelection();
        // if cursor is inside current selection then don't show hover, because editor.onDidChangeCursorPosition evaluates selected Text 
        // (see class Editor).
        if (selection != null) {
            if (selection.startLineNumber != selection.endLineNumber || selection.startColumn != selection.endColumn) {
                if ((selection.startLineNumber < position.lineNumber || selection.startLineNumber == position.lineNumber && selection.startColumn <= position.column) &&
                    (selection.endLineNumber > position.lineNumber || selection.endLineNumber == position.lineNumber && selection.endColumn >= position.column)) {
                    return;
                }
            }
        }
        let module = (_a = this.editor.main.getCurrentWorkspace()) === null || _a === void 0 ? void 0 : _a.getModuleByMonacoModel(model);
        if (module == null) {
            return null;
        }
        for (let errorList of module.errors) {
            for (let error of errorList) {
                if (error.position.line == position.lineNumber &&
                    error.position.column <= position.column &&
                    error.position.column + error.position.length >= position.column) {
                    return null; // Show error-tooltip and don't show hover-tooltip
                }
            }
        }
        let element = module.getElementAtPosition(position.lineNumber, position.column);
        let declarationAsString = "";
        if (element != null && element.identifier != "var") {
            if (element instanceof Klass || element instanceof Method || element instanceof Interface
                || element instanceof Attribute) {
                declarationAsString = getDeclarationAsString(element);
            }
            else if (element instanceof PrimitiveType) {
                declarationAsString = "```\n" + element.identifier + "\n```  \nprimitiver Datentyp: " + element.description + "";
                return {
                    range: null,
                    contents: [{ value: declarationAsString }],
                };
            }
            else {
                // Variable
                let typeIdentifier = (_b = element === null || element === void 0 ? void 0 : element.type) === null || _b === void 0 ? void 0 : _b.identifier;
                if ((element === null || element === void 0 ? void 0 : element.type) instanceof Klass || (element === null || element === void 0 ? void 0 : element.type) instanceof Interface) {
                    typeIdentifier += " " + getGenericParameterDefinition(element.type);
                }
                if (typeIdentifier == null) {
                    typeIdentifier = "";
                }
                else {
                    typeIdentifier += " ";
                }
                declarationAsString = typeIdentifier + (element === null || element === void 0 ? void 0 : element.identifier);
            }
        }
        else {
            let word = this.getWordUnderCursor(model, position);
            let desc = MyHoverProvider.keywordDescriptions[word];
            if (desc != null) {
                return {
                    range: null,
                    contents: [{ value: desc }],
                };
            }
        }
        let state = this.editor.main.getInterpreter().state;
        let value = null;
        if (state == InterpreterState.paused) {
            let evaluator = this.editor.main.getCurrentWorkspace().evaluator;
            let identifier = this.widenDeclaration(model, position, element === null || element === void 0 ? void 0 : element.identifier);
            if (identifier == null) {
                return null;
            }
            let result = evaluator.evaluate(identifier);
            if (result.error == null && result.value != null) {
                value = result.value.type.debugOutput(result.value);
                declarationAsString = identifier;
            }
        }
        let contents = [];
        if (value == null && declarationAsString.length == 0) {
            return null;
        }
        if (value != null) {
            if (value.length + declarationAsString.length > 40) {
                contents.push({ value: '```\n' + declarationAsString + ' ==\n```' });
                contents.push({ value: '```\n' + value.replace(/&nbsp;/g, " ") + '\n```' });
            }
            else {
                contents.push({ value: '```\n' + declarationAsString + " == " + value.replace(/&nbsp;/g, " ") + '\n```' });
            }
        }
        else {
            contents.push({ value: '```\n' + declarationAsString + '\n```' });
        }
        let range = null;
        return {
            range: range,
            contents: contents,
        };
    }
    getWordUnderCursor(model, position) {
        let pos = model.getValueLengthInRange({
            startColumn: 0,
            startLineNumber: 0,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        });
        let text = model.getValue();
        let word = "";
        let end = pos;
        while (end < text.length && this.isInsideIdentifierOrArrayDescriptor(text.charAt(end))) {
            end++;
        }
        let begin = pos;
        while (begin > 0 && this.isInsideIdentifierOrArrayDescriptor(text.charAt(begin - 1))) {
            begin--;
        }
        if (end - begin > 1) {
            word = text.substring(begin, end);
        }
        else {
            end = pos;
            while (end < text.length && this.isInsideOperator(text.charAt(end))) {
                end++;
            }
            begin = pos;
            while (begin > 0 && this.isInsideOperator(text.charAt(begin - 1))) {
                begin--;
            }
            if (end - begin > 0) {
                word = text.substring(begin, end);
            }
        }
        return word;
    }
    widenDeclaration(model, position, identifier) {
        let pos = model.getValueLengthInRange({
            startColumn: 0,
            startLineNumber: 0,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        });
        let text = model.getValue();
        let end = pos;
        while (end < text.length && this.isInsideIdentifierOrArrayDescriptor(text.charAt(end))) {
            end++;
        }
        let begin = pos;
        while (begin > 0 && this.isInsideIdentifierChain(text.charAt(begin - 1))) {
            begin--;
        }
        let lenght = (identifier === null || identifier === void 0 ? void 0 : identifier.length) == null ? 1 : identifier.length;
        if (end - begin > length) {
            return text.substring(begin, end);
        }
        return identifier;
    }
    isInsideIdentifierChain(t) {
        return t.toLocaleLowerCase().match(/[a-z0-9äöüß_\[\]\.]/i);
    }
    isInsideOperator(t) {
        return t.toLocaleLowerCase().match(/[!%<>=\+\-\*\/]/i);
    }
    isInsideIdentifierOrArrayDescriptor(t) {
        return t.toLocaleLowerCase().match(/[a-z0-9äöüß\[\]]/i);
    }
}
MyHoverProvider.keywordDescriptions = {
    "print": "Die Anweisung ```print``` gibt eine Zeichenkette aus.",
    "new": "Das Schlüsselwort ```new``` bewirkt die Instanzierung (\"Erschaffung\") eines neuen Objektes einer Klasse.",
    "println": "Die Anweisung ```println``` gibt eine Zeichenkette gefolgt von einem Zeilenumbruch aus.",
    "while": "```\nwhile (Bedingung) {Anweisungen}\n```  \nbewirkt die Wiederholung der Anweisungen solange ```Bedingung == true``` ist.",
    "for": "```\nfor(Startanweisung;Solange-Bedingung;Nach_jeder_Wiederholung){Anweisungen}\n```  \n"
        + "führt zunächst die Startanweisung aus und wiederholt dann die Anweisungen solange ```Bedingung == true``` ist. Am Ende jeder wiederholung wird Nach_jeder_Wiederholung ausgeführt.",
    "if": "```\nif(Bedingung){Anweisungen_1} else {Anweisungen_2}\n```  \nwertet die Bedingung aus und führt Anweisungen_1 nur dann aus, wenn die Bedingung ```true``` ergibt, Anweisungen_2 nur dann, wenn die Bedingung ```false``` ergibt.  \nDer ```else```-Teil kann auch weggelassen werden.",
    "else": "```\nif(Bedingung){Anweisungen_1} else {Anweisungen_2}\n```  \nwertet die Bedingung aus und führt Anweisungen_1 nur dann aus, wenn die Bedingung ```true``` ergibt, Anweisungen_2 nur dann, wenn die Bedingung ```false``` ergibt.",
    "switch": "```\nswitch(Selektor){ case Wert_1: Anweisungen_1; break; case Wert_2: Anweisungen_2; break; default: Default-Anweisungen } \n```  \nwertet den Selektor-Term aus und führt abhängig vom Termwert Anweisungen_1, Anweisungen_2, ... aus. Entspricht der Termwert keinem der Werte Wert_1, Wert_2, ..., so werden die Default-Anweisungen ausgeführt.",
    "%": "```\na % b\n```  \n (sprich: 'a modulo b') berechnet den **Rest** der ganzzahligen Division a/b.",
    "|": "```\na | b\n```  \n (sprich: 'a or b') berechnet die **bitweise oder-Verknüpfung** der Werte a und b.",
    "&": "```\na & b\n```  \n (sprich: 'a und b') berechnet die **bitweise und-Verknüpfung** der Werte a und b.",
    "^": "```\na ^ b\n```  \n (sprich: 'a xor b') berechnet die **bitweise exklusiv-oder-Verknüpfung** der Werte a und b.",
    ">>": "```\na >> b\n```  \n (sprich: 'a right shift b') berechnet den Wert, der entsteht, wenn man den Wert von a **bitweise um b Stellen nach rechts verschiebt**. Dieser Wert ist identisch mit dem nach unten abgerundeten Wert von a/(2 hoch b).",
    "<<": "```\na >> b\n```  \n (sprich: 'a left shift b') berechnet den Wert, der entsteht, wenn man den Wert von a **bitweise um b Stellen nach links verschiebt**. Dieser Wert ist identisch mit dem nach unten abgerundeten Wert von a*(2 hoch b).",
    "~": "```\n~a\n```  \n (sprich: 'nicht a') berechnet den Wert, der entsteht, wenn man **alle Bits von a umkehrt**.",
    "==": "```\na == b\n```  \nergibt genau dann ```true```, wenn ```a``` und ```b``` gleich sind.  \nSind a und b **Objekte**, so ergibt ```a == b``` nur dann ```true```, wenn ```a``` und ```b``` auf das **identische** Objekt zeigen.  \n```==``` nennt man **Vergleichsoperator**.",
    "<=": "```\na <= b\n```  \nergibt genau dann ```true```, wenn der Wert von ```a``` kleiner oder gleich dem Wert von ```b``` ist.",
    ">=": "```\na <= b\n```  \nergibt genau dann ```true```, wenn der Wert von ```a``` größer oder gleich dem Wert von ```b``` ist.",
    "!=": "```\na != b\n```  \nergibt genau dann ```true```, wenn ```a``` und ```b``` **un**gleich sind.  \nSind ```a``` und ```b``` **Objekte**, so ergibt ```a != b``` dann ```true```, wenn ```a``` und ```b``` **nicht** auf das **identische** Objekt zeigen.  \n```!=``` nennt man **Ungleich-Operator**.",
    "+=": "```\na += b\n(Kurzschreibweise für a = a + b)\n```  \nbewirkt, dass der Wert von ```a``` um den Wert von ```b``` **erhöht** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "-=": "```\na -= b\n(Kurzschreibweise für a = a - b)\n```  \nbewirkt, dass der Wert von ```a``` um den Wert von ```b``` **erniedrigt** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "*=": "```\na *= b\n(Kurzschreibweise für a = a * b)\n```  \nbewirkt, dass der Wert von ```a``` mit dem Wert von ```b``` **multipliziert** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "/=": "```\na /= b\n(Kurzschreibweise für a = a / b)\n```  \nbewirkt, dass der Wert von ```a``` durch den Wert von ```b``` **dividiert** wird. Das Ergebnis wird in die Variable ```a``` geschrieben.",
    "++": "```\na++\n(Kurzschreibweise für a = a + 1)\n```  \nbewirkt, dass der Wert von ```a``` um eins erhöht wird.",
    "--": "```\na--\n(Kurzschreibweise für a = a - 1)\n```  \nbewirkt, dass der Wert von ```a``` um eins eniedrigt wird.",
    "=": "```\na = Term\n```  \nberechnet den Wert des Terms und weist ihn der Variablen ```a``` zu.  \n**Vorsicht:**  \nVerwechsle ```=```(**Zuweisungsoperator**) nicht mit ```==```(**Vergleichsoperator**)!",
    "!": "```\n!a\n```  \nergibt genau dann ```true```, wenn ```a``` ```false``` ergibt.  \n```!``` spricht man '**nicht**'.",
    "public": "```\npublic\n```  \nAttribute und Methoden, die als ```public``` deklariert werden, sind überall (auch außerhalb der Klasse) sichtbar.",
    "private": "```\nprivate\n```  \nAttribute und Methoden, die als ```private``` deklariert werden, sind nur innerhalb von Methoden derselben Klasse sichtbar.",
    "protected": "```\nprotected\n```  \nAttribute und Methoden, die als ```protected``` deklariert werden, sind nur innerhalb von Methoden derselben Klasse oder innerhalb von Methoden von Kindklassen sichtbar.",
    "return": "```\nreturn Term\n```  \nbewirkt, dass die Methode verlassen wird und der Wert des Terms an die aufrufende Stelle zurückgegeben wird.",
    "break": "```\nbreak;\n```  \ninnerhalb einer Schleife bewirkt, dass die Schleife sofort verlassen und mit den Anweisungen nach der Schleife fortgefahren wird.  \n" +
        "```break``` innerhalb einer ```switch```-Anweisung bewirkt, dass der Block der ```switch```-Anweisung verlassen wird.",
    "class": "```\nclass\n```  \nMit dem Schlüsselwort ```class``` werden Klassen definiert.",
    "extends": "```\nextends\n```  \n```class A extends B { ... }``` bedeutet, dass die Klasse A Unterklasse der Klasse B ist.",
    "implements": "```\nimplements\n```  \n```class A implements B { ... }``` bedeutet, dass die Klasse A das Interface B implementiert, d.h., dass sie alle Methoden besitzen muss, die in B definiert sind.",
    "this": "```\nthis\n```  \nInnerhalb einer Methodendefinition bezeichnet das Schlüsselwort ```this``` immer dasjenige Objekt, für das die Methode gerade ausgeführt wird.",
    "var": "```\nvar\n```  \nWird einer Variable beim Deklarieren sofort ein Startwert zugewiesen (z.B. Circle c = new Circle(100, 100, 10)), so kann statt des Datentyps das Schlüsselwort ```var``` verwendet werden (also var c = new Circle(100, 100, 10)).",
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTXlIb3ZlclByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NsaWVudC9tYWluL2d1aS9NeUhvdmVyUHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNqRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNsSCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUlwRSxNQUFNLE9BQU8sZUFBZTtJQTRDeEIsWUFBb0IsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7SUFFbEMsQ0FBQztJQUVELFlBQVksQ0FBQyxLQUErQixFQUFFLFFBQXlCLEVBQUUsS0FBK0I7O1FBR3BHLElBQUksU0FBUyxHQUFxQixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUVwRSxpSUFBaUk7UUFDakksc0JBQXNCO1FBQ3RCLElBQUcsU0FBUyxJQUFJLElBQUksRUFBQztZQUNqQixJQUFHLFNBQVMsQ0FBQyxlQUFlLElBQUksU0FBUyxDQUFDLGFBQWEsSUFBSSxTQUFTLENBQUMsV0FBVyxJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUM7Z0JBQ3BHLElBQ0ksQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLGVBQWUsSUFBSSxRQUFRLENBQUMsVUFBVSxJQUFJLFNBQVMsQ0FBQyxXQUFXLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQztvQkFDakosQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQyxVQUFVLElBQUksU0FBUyxDQUFDLGFBQWEs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LEVBQUUsdUlBQXVJO0lBQ2pKLE9BQU8sRUFBRSwySkFBMko7UUFDcEssdUhBQXVIO0lBQ3ZILE9BQU8sRUFBRSxnRkFBZ0Y7SUFDekYsU0FBUyxFQUFFLGdIQUFnSDtJQUMzSCxZQUFZLEVBQUUsNExBQTRMO0lBQzFNLE1BQU0sRUFBRSxrS0FBa0s7SUFDMUssS0FBSyxFQUFFLHFQQUFxUDtDQUMvUCxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yIH0gZnJvbSBcIi4vRWRpdG9yLmpzXCI7XHJcbmltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuLi8uLi9jb21waWxlci9wYXJzZXIvTW9kdWxlLmpzXCI7XHJcbmltcG9ydCB7IEtsYXNzLCBJbnRlcmZhY2UgfSBmcm9tIFwiLi4vLi4vY29tcGlsZXIvdHlwZXMvQ2xhc3MuanNcIjtcclxuaW1wb3J0IHsgTWV0aG9kLCBBdHRyaWJ1dGUsIFByaW1pdGl2ZVR5cGUgfSBmcm9tIFwiLi4vLi4vY29tcGlsZXIvdHlwZXMvVHlwZXMuanNcIjtcclxuaW1wb3J0IHsgZ2V0RGVjbGFyYXRpb25Bc1N0cmluZywgZ2V0R2VuZXJpY1BhcmFtZXRlckRlZmluaXRpb24gfSBmcm9tIFwiLi4vLi4vY29tcGlsZXIvdHlwZXMvRGVjbGFyYXRpb25IZWxwZXIuanNcIjtcclxuaW1wb3J0IHsgSW50ZXJwcmV0ZXJTdGF0ZSB9IGZyb20gXCIuLi8uLi9pbnRlcnByZXRlci9JbnRlcnByZXRlci5qc1wiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTXlIb3ZlclByb3ZpZGVyIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBrZXl3b3JkRGVzY3JpcHRpb25zOiB7IFtrZXl3b3JkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICAgICAgICBcInByaW50XCI6IFwiRGllIEFud2Vpc3VuZyBgYGBwcmludGBgYCBnaWJ0IGVpbmUgWmVpY2hlbmtldHRlIGF1cy5cIixcclxuICAgICAgICBcIm5ld1wiOiBcIkRhcyBTY2hsw7xzc2Vsd29ydCBgYGBuZXdgYGAgYmV3aXJrdCBkaWUgSW5zdGFuemllcnVuZyAoXFxcIkVyc2NoYWZmdW5nXFxcIikgZWluZXMgbmV1ZW4gT2JqZWt0ZXMgZWluZXIgS2xhc3NlLlwiLFxyXG4gICAgICAgIFwicHJpbnRsblwiOiBcIkRpZSBBbndlaXN1bmcgYGBgcHJpbnRsbmBgYCBnaWJ0IGVpbmUgWmVpY2hlbmtldHRlIGdlZm9sZ3Qgdm9uIGVpbmVtIFplaWxlbnVtYnJ1Y2ggYXVzLlwiLFxyXG4gICAgICAgIFwid2hpbGVcIjogXCJgYGBcXG53aGlsZSAoQmVkaW5ndW5nKSB7QW53ZWlzdW5nZW59XFxuYGBgICBcXG5iZXdpcmt0IGRpZSBXaWVkZXJob2x1bmcgZGVyIEFud2Vpc3VuZ2VuIHNvbGFuZ2UgYGBgQmVkaW5ndW5nID09IHRydWVgYGAgaXN0LlwiLFxyXG4gICAgICAgIFwiZm9yXCI6IFwiYGBgXFxuZm9yKFN0YXJ0YW53ZWlzdW5nO1NvbGFuZ2UtQmVkaW5ndW5nO05hY2hfamVkZXJfV2llZGVyaG9sdW5nKXtBbndlaXN1bmdlbn1cXG5gYGAgIFxcblwiXHJcbiAgICAgICAgICAgICsgXCJmw7xocnQgenVuw6RjaHN0IGRpZSBTdGFydGFud2Vpc3VuZyBhdXMgdW5kIHdpZWRlcmhvbHQgZGFubiBkaWUgQW53ZWlzdW5nZW4gc29sYW5nZSBgYGBCZWRpbmd1bmcgPT0gdHJ1ZWBgYCBpc3QuIEFtIEVuZGUgamVkZXIgd2llZGVyaG9sdW5nIHdpcmQgTmFjaF9qZWRlcl9XaWVkZXJob2x1bmcgYXVzZ2Vmw7xocnQuXCIsXHJcbiAgICAgICAgXCJpZlwiOiBcImBgYFxcbmlmKEJlZGluZ3VuZyl7QW53ZWlzdW5nZW5fMX0gZWxzZSB7QW53ZWlzdW5nZW5fMn1cXG5gYGAgIFxcbndlcnRldCBkaWUgQmVkaW5ndW5nIGF1cyB1bmQgZsO8aHJ0IEFud2Vpc3VuZ2VuXzEgbnVyIGRhbm4gYXVzLCB3ZW5uIGRpZSBCZWRpbmd1bmcgYGBgdHJ1ZWBgYCBlcmdpYnQsIEFud2Vpc3VuZ2VuXzIgbnVyIGRhbm4sIHdlbm4gZGllIEJlZGluZ3VuZyBgYGBmYWxzZWBgYCBlcmdpYnQuICBcXG5EZXIgYGBgZWxzZWBgYC1UZWlsIGthbm4gYXVjaCB3ZWdnZWxhc3NlbiB3ZXJkZW4uXCIsXHJcbiAgICAgICAgXCJlbHNlXCI6IFwiYGBgXFxuaWYoQmVkaW5ndW5nKXtBbndlaXN1bmdlbl8xfSBlbHNlIHtBbndlaXN1bmdlbl8yfVxcbmBgYCAgXFxud2VydGV0IGRpZSBCZWRpbmd1bmcgYXVzIHVuZCBmw7xocnQgQW53ZWlzdW5nZW5fMSBudXIgZGFubiBhdXMsIHdlbm4gZGllIEJlZGluZ3VuZyBgYGB0cnVlYGBgIGVyZ2lidCwgQW53ZWlzdW5nZW5fMiBudXIgZGFubiwgd2VubiBkaWUgQmVkaW5ndW5nIGBgYGZhbHNlYGBgIGVyZ2lidC5cIixcclxuICAgICAgICBcInN3aXRjaFwiOiBcImBgYFxcbnN3aXRjaChTZWxla3Rvcil7IGNhc2UgV2VydF8xOiBBbndlaXN1bmdlbl8xOyBicmVhazsgY2FzZSBXZXJ0XzI6IEFud2Vpc3VuZ2VuXzI7IGJyZWFrOyBkZWZhdWx0OiBEZWZhdWx0LUFud2Vpc3VuZ2VuIH0gXFxuYGBgICBcXG53ZXJ0ZXQgZGVuIFNlbGVrdG9yLVRlcm0gYXVzIHVuZCBmw7xocnQgYWJow6RuZ2lnIHZvbSBUZXJtd2VydCBBbndlaXN1bmdlbl8xLCBBbndlaXN1bmdlbl8yLCAuLi4gYXVzLiBFbnRzcHJpY2h0IGRlciBUZXJtd2VydCBrZWluZW0gZGVyIFdlcnRlIFdlcnRfMSwgV2VydF8yLCAuLi4sIHNvIHdlcmRlbiBkaWUgRGVmYXVsdC1BbndlaXN1bmdlbiBhdXNnZWbDvGhydC5cIixcclxuICAgICAgICBcIiVcIjogXCJgYGBcXG5hICUgYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIG1vZHVsbyBiJykgYmVyZWNobmV0IGRlbiAqKlJlc3QqKiBkZXIgZ2FuenphaGxpZ2VuIERpdmlzaW9uIGEvYi5cIixcclxuICAgICAgICBcInxcIjogXCJgYGBcXG5hIHwgYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIG9yIGInKSBiZXJlY2huZXQgZGllICoqYml0d2Vpc2Ugb2Rlci1WZXJrbsO8cGZ1bmcqKiBkZXIgV2VydGUgYSB1bmQgYi5cIixcclxuICAgICAgICBcIiZcIjogXCJgYGBcXG5hICYgYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIHVuZCBiJykgYmVyZWNobmV0IGRpZSAqKmJpdHdlaXNlIHVuZC1WZXJrbsO8cGZ1bmcqKiBkZXIgV2VydGUgYSB1bmQgYi5cIixcclxuICAgICAgICBcIl5cIjogXCJgYGBcXG5hIF4gYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIHhvciBiJykgYmVyZWNobmV0IGRpZSAqKmJpdHdlaXNlIGV4a2x1c2l2LW9kZXItVmVya27DvHBmdW5nKiogZGVyIFdlcnRlIGEgdW5kIGIuXCIsXHJcbiAgICAgICAgXCI+PlwiOiBcImBgYFxcbmEgPj4gYlxcbmBgYCAgXFxuIChzcHJpY2g6ICdhIHJpZ2h0IHNoaWZ0IGInKSBiZXJlY2huZXQgZGVuIFdlcnQsIGRlciBlbnRzdGVodCwgd2VubiBtYW4gZGVuIFdlcnQgdm9uIGEgKipiaXR3ZWlzZSB1bSBiIFN0ZWxsZW4gbmFjaCByZWNodHMgdmVyc2NoaWVidCoqLiBEaWVzZXIgV2VydCBpc3QgaWRlbnRpc2NoIG1pdCBkZW0gbmFjaCB1bnRlbiBhYmdlcnVuZGV0ZW4gV2VydCB2b24gYS8oMiBob2NoIGIpLlwiLFxyXG4gICAgICAgIFwiPDxcIjogXCJgYGBcXG5hID4+IGJcXG5gYGAgIFxcbiAoc3ByaWNoOiAnYSBsZWZ0IHNoaWZ0IGInKSBiZXJlY2huZXQgZGVuIFdlcnQsIGRlciBlbnRzdGVodCwgd2VubiBtYW4gZGVuIFdlcnQgdm9uIGEgKipiaXR3ZWlzZSB1bSBiIFN0ZWxsZW4gbmFjaCBsaW5rcyB2ZXJzY2hpZWJ0KiouIERpZXNlciBXZXJ0IGlzdCBpZGVudGlzY2ggbWl0IGRlbSBuYWNoIHVudGVuIGFiZ2VydW5kZXRlbiBXZXJ0IHZvbiBhKigyIGhvY2ggYikuXCIsXHJcbiAgICAgICAgXCJ+XCI6IFwiYGBgXFxufmFcXG5gYGAgIFxcbiAoc3ByaWNoOiAnbmljaHQgYScpIGJlcmVjaG5ldCBkZW4gV2VydCwgZGVyIGVudHN0ZWh0LCB3ZW5uIG1hbiAqKmFsbGUgQml0cyB2b24gYSB1bWtlaHJ0KiouXCIsXHJcbiAgICAgICAgXCI9PVwiOiBcImBgYFxcbmEgPT0gYlxcbmBgYCAgXFxuZXJnaWJ0IGdlbmF1IGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBgYGBhYGBgIHVuZCBgYGBiYGBgIGdsZWljaCBzaW5kLiAgXFxuU2luZCBhIHVuZCBiICoqT2JqZWt0ZSoqLCBzbyBlcmdpYnQgYGBgYSA9PSBiYGBgIG51ciBkYW5uIGBgYHRydWVgYGAsIHdlbm4gYGBgYWBgYCB1bmQgYGBgYmBgYCBhdWYgZGFzICoqaWRlbnRpc2NoZSoqIE9iamVrdCB6ZWlnZW4uICBcXG5gYGA9PWBgYCBuZW5udCBtYW4gKipWZXJnbGVpY2hzb3BlcmF0b3IqKi5cIixcclxuICAgICAgICBcIjw9XCI6IFwiYGBgXFxuYSA8PSBiXFxuYGBgICBcXG5lcmdpYnQgZ2VuYXUgZGFubiBgYGB0cnVlYGBgLCB3ZW5uIGRlciBXZXJ0IHZvbiBgYGBhYGBgIGtsZWluZXIgb2RlciBnbGVpY2ggZGVtIFdlcnQgdm9uIGBgYGJgYGAgaXN0LlwiLFxyXG4gICAgICAgIFwiPj1cIjogXCJgYGBcXG5hIDw9IGJcXG5gYGAgIFxcbmVyZ2lidCBnZW5hdSBkYW5uIGBgYHRydWVgYGAsIHdlbm4gZGVyIFdlcnQgdm9uIGBgYGFgYGAgZ3LDtsOfZXIgb2RlciBnbGVpY2ggZGVtIFdlcnQgdm9uIGBgYGJgYGAgaXN0LlwiLFxyXG4gICAgICAgIFwiIT1cIjogXCJgYGBcXG5hICE9IGJcXG5gYGAgIFxcbmVyZ2lidCBnZW5hdSBkYW5uIGBgYHRydWVgYGAsIHdlbm4gYGBgYWBgYCB1bmQgYGBgYmBgYCAqKnVuKipnbGVpY2ggc2luZC4gIFxcblNpbmQgYGBgYWBgYCB1bmQgYGBgYmBgYCAqKk9iamVrdGUqKiwgc28gZXJnaWJ0IGBgYGEgIT0gYmBgYCBkYW5uIGBgYHRydWVgYGAsIHdlbm4gYGBgYWBgYCB1bmQgYGBgYmBgYCAqKm5pY2h0KiogYXVmIGRhcyAqKmlkZW50aXNjaGUqKiBPYmpla3QgemVpZ2VuLiAgXFxuYGBgIT1gYGAgbmVubnQgbWFuICoqVW5nbGVpY2gtT3BlcmF0b3IqKi5cIixcclxuICAgICAgICBcIis9XCI6IFwiYGBgXFxuYSArPSBiXFxuKEt1cnpzY2hyZWlid2Vpc2UgZsO8ciBhID0gYSArIGIpXFxuYGBgICBcXG5iZXdpcmt0LCBkYXNzIGRlciBXZXJ0IHZvbiBgYGBhYGBgIHVtIGRlbiBXZXJ0IHZvbiBgYGBiYGBgICoqZXJow7ZodCoqIHdpcmQuIERhcyBFcmdlYm5pcyB3aXJkIGluIGRpZSBWYXJpYWJsZSBgYGBhYGBgIGdlc2NocmllYmVuLlwiLFxyXG4gICAgICAgIFwiLT1cIjogXCJgYGBcXG5hIC09IGJcXG4oS3VyenNjaHJlaWJ3ZWlzZSBmw7xyIGEgPSBhIC0gYilcXG5gYGAgIFxcbmJld2lya3QsIGRhc3MgZGVyIFdlcnQgdm9uIGBgYGFgYGAgdW0gZGVuIFdlcnQgdm9uIGBgYGJgYGAgKiplcm5pZWRyaWd0Kiogd2lyZC4gRGFzIEVyZ2VibmlzIHdpcmQgaW4gZGllIFZhcmlhYmxlIGBgYGFgYGAgZ2VzY2hyaWViZW4uXCIsXHJcbiAgICAgICAgXCIqPVwiOiBcImBgYFxcbmEgKj0gYlxcbihLdXJ6c2NocmVpYndlaXNlIGbDvHIgYSA9IGEgKiBiKVxcbmBgYCAgXFxuYmV3aXJrdCwgZGFzcyBkZXIgV2VydCB2b24gYGBgYWBgYCBtaXQgZGVtIFdlcnQgdm9uIGBgYGJgYGAgKiptdWx0aXBsaXppZXJ0Kiogd2lyZC4gRGFzIEVyZ2VibmlzIHdpcmQgaW4gZGllIFZhcmlhYmxlIGBgYGFgYGAgZ2VzY2hyaWViZW4uXCIsXHJcbiAgICAgICAgXCIvPVwiOiBcImBgYFxcbmEgLz0gYlxcbihLdXJ6c2NocmVpYndlaXNlIGbDvHIgYSA9IGEgLyBiKVxcbmBgYCAgXFxuYmV3aXJrdCwgZGFzcyBkZXIgV2VydCB2b24gYGBgYWBgYCBkdXJjaCBkZW4gV2VydCB2b24gYGBgYmBgYCAqKmRpdmlkaWVydCoqIHdpcmQuIERhcyBFcmdlYm5pcyB3aXJkIGluIGRpZSBWYXJpYWJsZSBgYGBhYGBgIGdlc2NocmllYmVuLlwiLFxyXG4gICAgICAgIFwiKytcIjogXCJgYGBcXG5hKytcXG4oS3VyenNjaHJlaWJ3ZWlzZSBmw7xyIGEgPSBhICsgMSlcXG5gYGAgIFxcbmJld2lya3QsIGRhc3MgZGVyIFdlcnQgdm9uIGBgYGFgYGAgdW0gZWlucyBlcmjDtmh0IHdpcmQuXCIsXHJcbiAgICAgICAgXCItLVwiOiBcImBgYFxcbmEtLVxcbihLdXJ6c2NocmVpYndlaXNlIGbDvHIgYSA9IGEgLSAxKVxcbmBgYCAgXFxuYmV3aXJrdCwgZGFzcyBkZXIgV2VydCB2b24gYGBgYWBgYCB1bSBlaW5zIGVuaWVkcmlndCB3aXJkLlwiLFxyXG4gICAgICAgIFwiPVwiOiBcImBgYFxcbmEgPSBUZXJtXFxuYGBgICBcXG5iZXJlY2huZXQgZGVuIFdlcnQgZGVzIFRlcm1zIHVuZCB3ZWlzdCBpaG4gZGVyIFZhcmlhYmxlbiBgYGBhYGBgIHp1LiAgXFxuKipWb3JzaWNodDoqKiAgXFxuVmVyd2VjaHNsZSBgYGA9YGBgKCoqWnV3ZWlzdW5nc29wZXJhdG9yKiopIG5pY2h0IG1pdCBgYGA9PWBgYCgqKlZlcmdsZWljaHNvcGVyYXRvcioqKSFcIixcclxuICAgICAgICBcIiFcIjogXCJgYGBcXG4hYVxcbmBgYCAgXFxuZXJnaWJ0IGdlbmF1IGRhbm4gYGBgdHJ1ZWBgYCwgd2VubiBgYGBhYGBgIGBgYGZhbHNlYGBgIGVyZ2lidC4gIFxcbmBgYCFgYGAgc3ByaWNodCBtYW4gJyoqbmljaHQqKicuXCIsXHJcbiAgICAgICAgXCJwdWJsaWNcIjogXCJgYGBcXG5wdWJsaWNcXG5gYGAgIFxcbkF0dHJpYnV0ZSB1bmQgTWV0aG9kZW4sIGRpZSBhbHMgYGBgcHVibGljYGBgIGRla2xhcmllcnQgd2VyZGVuLCBzaW5kIMO8YmVyYWxsIChhdWNoIGF1w59lcmhhbGIgZGVyIEtsYXNzZSkgc2ljaHRiYXIuXCIsXHJcbiAgICAgICAgXCJwcml2YXRlXCI6IFwiYGBgXFxucHJpdmF0ZVxcbmBgYCAgXFxuQXR0cmlidXRlIHVuZCBNZXRob2RlbiwgZGllIGFscyBgYGBwcml2YXRlYGBgIGRla2xhcmllcnQgd2VyZGVuLCBzaW5kIG51ciBpbm5lcmhhbGIgdm9uIE1ldGhvZGVuIGRlcnNlbGJlbiBLbGFzc2Ugc2ljaHRiYXIuXCIsXHJcbiAgICAgICAgXCJwcm90ZWN0ZWRcIjogXCJgYGBcXG5wcm90ZWN0ZWRcXG5gYGAgIFxcbkF0dHJpYnV0ZSB1bmQgTWV0aG9kZW4sIGRpZSBhbHMgYGBgcHJvdGVjdGVkYGBgIGRla2xhcmllcnQgd2VyZGVuLCBzaW5kIG51ciBpbm5lcmhhbGIgdm9uIE1ldGhvZGVuIGRlcnNlbGJlbiBLbGFzc2Ugb2RlciBpbm5lcmhhbGIgdm9uIE1ldGhvZGVuIHZvbiBLaW5ka2xhc3NlbiBzaWNodGJhci5cIixcclxuICAgICAgICBcInJldHVyblwiOiBcImBgYFxcbnJldHVybiBUZXJtXFxuYGBgICBcXG5iZXdpcmt0LCBkYXNzIGRpZSBNZXRob2RlIHZlcmxhc3NlbiB3aXJkIHVuZCBkZXIgV2VydCBkZXMgVGVybXMgYW4gZGllIGF1ZnJ1ZmVuZGUgU3RlbGxlIHp1csO8Y2tnZWdlYmVuIHdpcmQuXCIsXHJcbiAgICAgICAgXCJicmVha1wiOiBcImBgYFxcbmJyZWFrO1xcbmBgYCAgXFxuaW5uZXJoYWxiIGVpbmVyIFNjaGxlaWZlIGJld2lya3QsIGRhc3MgZGllIFNjaGxlaWZlIHNvZm9ydCB2ZXJsYXNzZW4gdW5kIG1pdCBkZW4gQW53ZWlzdW5nZW4gbmFjaCBkZXIgU2NobGVpZmUgZm9ydGdlZmFocmVuIHdpcmQuICBcXG5cIitcclxuICAgICAgICBcImBgYGJyZWFrYGBgIGlubmVyaGFsYiBlaW5lciBgYGBzd2l0Y2hgYGAtQW53ZWlzdW5nIGJld2lya3QsIGRhc3MgZGVyIEJsb2NrIGRlciBgYGBzd2l0Y2hgYGAtQW53ZWlzdW5nIHZlcmxhc3NlbiB3aXJkLlwiLFxyXG4gICAgICAgIFwiY2xhc3NcIjogXCJgYGBcXG5jbGFzc1xcbmBgYCAgXFxuTWl0IGRlbSBTY2hsw7xzc2Vsd29ydCBgYGBjbGFzc2BgYCB3ZXJkZW4gS2xhc3NlbiBkZWZpbmllcnQuXCIsXHJcbiAgICAgICAgXCJleHRlbmRzXCI6IFwiYGBgXFxuZXh0ZW5kc1xcbmBgYCAgXFxuYGBgY2xhc3MgQSBleHRlbmRzIEIgeyAuLi4gfWBgYCBiZWRldXRldCwgZGFzcyBkaWUgS2xhc3NlIEEgVW50ZXJrbGFzc2UgZGVyIEtsYXNzZSBCIGlzdC5cIixcclxuICAgICAgICBcImltcGxlbWVudHNcIjogXCJgYGBcXG5pbXBsZW1lbnRzXFxuYGBgICBcXG5gYGBjbGFzcyBBIGltcGxlbWVudHMgQiB7IC4uLiB9YGBgIGJlZGV1dGV0LCBkYXNzIGRpZSBLbGFzc2UgQSBkYXMgSW50ZXJmYWNlIEIgaW1wbGVtZW50aWVydCwgZC5oLiwgZGFzcyBzaWUgYWxsZSBNZXRob2RlbiBiZXNpdHplbiBtdXNzLCBkaWUgaW4gQiBkZWZpbmllcnQgc2luZC5cIixcclxuICAgICAgICBcInRoaXNcIjogXCJgYGBcXG50aGlzXFxuYGBgICBcXG5Jbm5lcmhhbGIgZWluZXIgTWV0aG9kZW5kZWZpbml0aW9uIGJlemVpY2huZXQgZGFzIFNjaGzDvHNzZWx3b3J0IGBgYHRoaXNgYGAgaW1tZXIgZGFzamVuaWdlIE9iamVrdCwgZsO8ciBkYXMgZGllIE1ldGhvZGUgZ2VyYWRlIGF1c2dlZsO8aHJ0IHdpcmQuXCIsXHJcbiAgICAgICAgXCJ2YXJcIjogXCJgYGBcXG52YXJcXG5gYGAgIFxcbldpcmQgZWluZXIgVmFyaWFibGUgYmVpbSBEZWtsYXJpZXJlbiBzb2ZvcnQgZWluIFN0YXJ0d2VydCB6dWdld2llc2VuICh6LkIuIENpcmNsZSBjID0gbmV3IENpcmNsZSgxMDAsIDEwMCwgMTApKSwgc28ga2FubiBzdGF0dCBkZXMgRGF0ZW50eXBzIGRhcyBTY2hsw7xzc2Vsd29ydCBgYGB2YXJgYGAgdmVyd2VuZGV0IHdlcmRlbiAoYWxzbyB2YXIgYyA9IG5ldyBDaXJjbGUoMTAwLCAxMDAsIDEwKSkuXCIsXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlZGl0b3I6IEVkaXRvcikge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcm92aWRlSG92ZXIobW9kZWw6IG1vbmFjby5lZGl0b3IuSVRleHRNb2RlbCwgcG9zaXRpb246IG1vbmFjby5Qb3NpdGlvbiwgdG9rZW46IG1vbmFjby5DYW5jZWxsYXRpb25Ub2tlbik6XHJcbiAgICAgICAgbW9uYWNvLmxhbmd1YWdlcy5Qcm92aWRlclJlc3VsdDxtb25hY28ubGFuZ3VhZ2VzLkhvdmVyPiB7XHJcblxyXG4gICAgICAgIGxldCBzZWxlY3Rpb246IG1vbmFjby5TZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gaWYgY3Vyc29yIGlzIGluc2lkZSBjdXJyZW50IHNlbGVjdGlvbiB0aGVuIGRvbid0IHNob3cgaG92ZXIsIGJlY2F1c2UgZWRpdG9yLm9uRGlkQ2hhbmdlQ3Vyc29yUG9zaXRpb24gZXZhbHVhdGVzIHNlbGVjdGVkIFRleHQgXHJcbiAgICAgICAgLy8gKHNlZSBjbGFzcyBFZGl0b3IpLlxyXG4gICAgICAgIGlmKHNlbGVjdGlvbiAhPSBudWxsKXtcclxuICAgICAgICAgICAgaWYoc2VsZWN0aW9uLnN0YXJ0TGluZU51bWJlciAhPSBzZWxlY3Rpb24uZW5kTGluZU51bWJlciB8fCBzZWxlY3Rpb24uc3RhcnRDb2x1bW4gIT0gc2VsZWN0aW9uLmVuZENvbHVtbil7XHJcbiAgICAgICAgICAgICAgICBpZihcclxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0aW9uLnN0YXJ0TGluZU51bWJlciA8IHBvc2l0aW9uLmxpbmVOdW1iZXIgfHwgc2VsZWN0aW9uLnN0YXJ0TGluZU51bWJlciA9PSBwb3NpdGlvbi5saW5lTnVtYmVyICYmIHNlbGVjdGlvbi5zdGFydENvbHVtbiA8PSBwb3NpdGlvbi5jb2x1bW4pICYmIFxyXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb24uZW5kTGluZU51bWJlciA+IHBvc2l0aW9uLmxpbmVOdW1iZXIgfHwgc2VsZWN0aW9uLmVuZExpbmVOdW1iZXIgPT0gcG9zaXRpb24ubGluZU51bWJlciAmJiBzZWxlY3Rpb24uZW5kQ29sdW1uID49IHBvc2l0aW9uLmNvbHVtbikgXHJcbiAgICAgICAgICAgICAgICApe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG1vZHVsZTogTW9kdWxlID0gdGhpcy5lZGl0b3IubWFpbi5nZXRDdXJyZW50V29ya3NwYWNlKCk/LmdldE1vZHVsZUJ5TW9uYWNvTW9kZWwobW9kZWwpO1xyXG5cclxuICAgICAgICBpZiAobW9kdWxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IobGV0IGVycm9yTGlzdCBvZiBtb2R1bGUuZXJyb3JzKXtcclxuICAgICAgICAgICAgZm9yKGxldCBlcnJvciBvZiBlcnJvckxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgaWYoZXJyb3IucG9zaXRpb24ubGluZSA9PSBwb3NpdGlvbi5saW5lTnVtYmVyICYmIFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnBvc2l0aW9uLmNvbHVtbiA8PSBwb3NpdGlvbi5jb2x1bW4gJiYgXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucG9zaXRpb24uY29sdW1uICsgZXJyb3IucG9zaXRpb24ubGVuZ3RoID49IHBvc2l0aW9uLmNvbHVtbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBTaG93IGVycm9yLXRvb2x0aXAgYW5kIGRvbid0IHNob3cgaG92ZXItdG9vbHRpcFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBtb2R1bGUuZ2V0RWxlbWVudEF0UG9zaXRpb24ocG9zaXRpb24ubGluZU51bWJlciwgcG9zaXRpb24uY29sdW1uKTtcclxuXHJcbiAgICAgICAgbGV0IGRlY2xhcmF0aW9uQXNTdHJpbmcgPSBcIlwiO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQuaWRlbnRpZmllciAhPSBcInZhclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgS2xhc3MgfHwgZWxlbWVudCBpbnN0YW5jZW9mIE1ldGhvZCB8fCBlbGVtZW50IGluc3RhbmNlb2YgSW50ZXJmYWNlXHJcbiAgICAgICAgICAgICAgICB8fCBlbGVtZW50IGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbkFzU3RyaW5nID0gZ2V0RGVjbGFyYXRpb25Bc1N0cmluZyhlbGVtZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgUHJpbWl0aXZlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25Bc1N0cmluZyA9IFwiYGBgXFxuXCIgKyBlbGVtZW50LmlkZW50aWZpZXIgKyBcIlxcbmBgYCAgXFxucHJpbWl0aXZlciBEYXRlbnR5cDogXCIgKyBlbGVtZW50LmRlc2NyaXB0aW9uICsgXCJcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IFt7IHZhbHVlOiBkZWNsYXJhdGlvbkFzU3RyaW5nIH1dLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVmFyaWFibGVcclxuICAgICAgICAgICAgICAgIGxldCB0eXBlSWRlbnRpZmllcjogc3RyaW5nID0gZWxlbWVudD8udHlwZT8uaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQ/LnR5cGUgaW5zdGFuY2VvZiBLbGFzcyB8fCBlbGVtZW50Py50eXBlIGluc3RhbmNlb2YgSW50ZXJmYWNlKXtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSWRlbnRpZmllciArPSBcIiBcIiArIGdldEdlbmVyaWNQYXJhbWV0ZXJEZWZpbml0aW9uKGVsZW1lbnQudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVJZGVudGlmaWVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSWRlbnRpZmllciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZGVudGlmaWVyICs9IFwiIFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uQXNTdHJpbmcgPSB0eXBlSWRlbnRpZmllciArIGVsZW1lbnQ/LmlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgd29yZCA9IHRoaXMuZ2V0V29yZFVuZGVyQ3Vyc29yKG1vZGVsLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBkZXNjID0gTXlIb3ZlclByb3ZpZGVyLmtleXdvcmREZXNjcmlwdGlvbnNbd29yZF07XHJcbiAgICAgICAgICAgIGlmIChkZXNjICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IFt7IHZhbHVlOiBkZXNjIH1dLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmVkaXRvci5tYWluLmdldEludGVycHJldGVyKCkuc3RhdGU7XHJcblxyXG4gICAgICAgIGxldCB2YWx1ZTogc3RyaW5nID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlID09IEludGVycHJldGVyU3RhdGUucGF1c2VkKSB7XHJcbiAgICAgICAgICAgIGxldCBldmFsdWF0b3IgPSB0aGlzLmVkaXRvci5tYWluLmdldEN1cnJlbnRXb3Jrc3BhY2UoKS5ldmFsdWF0b3I7XHJcblxyXG4gICAgICAgICAgICBsZXQgaWRlbnRpZmllcjogc3RyaW5nID0gdGhpcy53aWRlbkRlY2xhcmF0aW9uKG1vZGVsLCBwb3NpdGlvbiwgZWxlbWVudD8uaWRlbnRpZmllcik7XHJcblxyXG4gICAgICAgICAgICBpZihpZGVudGlmaWVyID09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBldmFsdWF0b3IuZXZhbHVhdGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IgPT0gbnVsbCAmJiByZXN1bHQudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWUudHlwZS5kZWJ1Z091dHB1dChyZXN1bHQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25Bc1N0cmluZyA9IGlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgZGVjbGFyYXRpb25Bc1N0cmluZy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggKyBkZWNsYXJhdGlvbkFzU3RyaW5nLmxlbmd0aCA+IDQwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50cy5wdXNoKHsgdmFsdWU6ICdgYGBcXG4nICsgZGVjbGFyYXRpb25Bc1N0cmluZyArICcgPT1cXG5gYGAnIH0pO1xyXG4gICAgICAgICAgICAgICAgY29udGVudHMucHVzaCh7IHZhbHVlOiAnYGBgXFxuJyArIHZhbHVlLnJlcGxhY2UoLyZuYnNwOy9nLCBcIiBcIikgKyAnXFxuYGBgJyB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRzLnB1c2goeyB2YWx1ZTogJ2BgYFxcbicgKyBkZWNsYXJhdGlvbkFzU3RyaW5nICsgXCIgPT0gXCIgKyB2YWx1ZS5yZXBsYWNlKC8mbmJzcDsvZywgXCIgXCIpICsgJ1xcbmBgYCcgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50cy5wdXNoKHsgdmFsdWU6ICdgYGBcXG4nICsgZGVjbGFyYXRpb25Bc1N0cmluZyArICdcXG5gYGAnIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJhbmdlID0gbnVsbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgICAgICBjb250ZW50czogY29udGVudHMsXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRXb3JkVW5kZXJDdXJzb3IobW9kZWw6IG1vbmFjby5lZGl0b3IuSVRleHRNb2RlbCwgcG9zaXRpb246IG1vbmFjby5Qb3NpdGlvbilcclxuICAgICAgICAgOiBzdHJpbmcge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBwb3MgPSBtb2RlbC5nZXRWYWx1ZUxlbmd0aEluUmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydENvbHVtbjogMCxcclxuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiAwLFxyXG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBwb3NpdGlvbi5saW5lTnVtYmVyLFxyXG4gICAgICAgICAgICBlbmRDb2x1bW46IHBvc2l0aW9uLmNvbHVtblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgdGV4dCA9IG1vZGVsLmdldFZhbHVlKCk7XHJcblxyXG4gICAgICAgIGxldCB3b3JkID0gXCJcIjtcclxuXHJcbiAgICAgICAgbGV0IGVuZCA9IHBvcztcclxuICAgICAgICB3aGlsZSAoZW5kIDwgdGV4dC5sZW5ndGggJiYgdGhpcy5pc0luc2lkZUlkZW50aWZpZXJPckFycmF5RGVzY3JpcHRvcih0ZXh0LmNoYXJBdChlbmQpKSkge1xyXG4gICAgICAgICAgICBlbmQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBiZWdpbiA9IHBvcztcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmIHRoaXMuaXNJbnNpZGVJZGVudGlmaWVyT3JBcnJheURlc2NyaXB0b3IodGV4dC5jaGFyQXQoYmVnaW4gLSAxKSkpIHtcclxuICAgICAgICAgICAgYmVnaW4tLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbmQgLSBiZWdpbiA+IDEpIHtcclxuICAgICAgICAgICAgd29yZCA9IHRleHQuc3Vic3RyaW5nKGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHBvcztcclxuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IHRleHQubGVuZ3RoICYmIHRoaXMuaXNJbnNpZGVPcGVyYXRvcih0ZXh0LmNoYXJBdChlbmQpKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBiZWdpbiA9IHBvcztcclxuICAgICAgICAgICAgd2hpbGUgKGJlZ2luID4gMCAmJiB0aGlzLmlzSW5zaWRlT3BlcmF0b3IodGV4dC5jaGFyQXQoYmVnaW4gLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIGJlZ2luLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBpZiAoZW5kIC0gYmVnaW4gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JkID0gdGV4dC5zdWJzdHJpbmcoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB3b3JkO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB3aWRlbkRlY2xhcmF0aW9uKG1vZGVsOiBtb25hY28uZWRpdG9yLklUZXh0TW9kZWwsIHBvc2l0aW9uOiBtb25hY28uUG9zaXRpb24sXHJcbiAgICAgICAgaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgbGV0IHBvcyA9IG1vZGVsLmdldFZhbHVlTGVuZ3RoSW5SYW5nZSh7XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiAwLFxyXG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IDAsXHJcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IHBvc2l0aW9uLmxpbmVOdW1iZXIsXHJcbiAgICAgICAgICAgIGVuZENvbHVtbjogcG9zaXRpb24uY29sdW1uXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCB0ZXh0ID0gbW9kZWwuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgbGV0IGVuZCA9IHBvcztcclxuICAgICAgICB3aGlsZSAoZW5kIDwgdGV4dC5sZW5ndGggJiYgdGhpcy5pc0luc2lkZUlkZW50aWZpZXJPckFycmF5RGVzY3JpcHRvcih0ZXh0LmNoYXJBdChlbmQpKSkge1xyXG4gICAgICAgICAgICBlbmQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBiZWdpbiA9IHBvcztcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPiAwICYmIHRoaXMuaXNJbnNpZGVJZGVudGlmaWVyQ2hhaW4odGV4dC5jaGFyQXQoYmVnaW4gLSAxKSkpIHtcclxuICAgICAgICAgICAgYmVnaW4tLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsZW5naHQ6IG51bWJlciA9IGlkZW50aWZpZXI/Lmxlbmd0aCA9PSBudWxsID8gMSA6IGlkZW50aWZpZXIubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZW5kIC0gYmVnaW4gPiBsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICB9XHJcblxyXG4gICAgaXNJbnNpZGVJZGVudGlmaWVyQ2hhaW4odDogc3RyaW5nKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0LnRvTG9jYWxlTG93ZXJDYXNlKCkubWF0Y2goL1thLXowLTnDpMO2w7zDn19cXFtcXF1cXC5dL2kpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpc0luc2lkZU9wZXJhdG9yKHQ6IHN0cmluZykge1xyXG5cclxuICAgICAgICByZXR1cm4gdC50b0xvY2FsZUxvd2VyQ2FzZSgpLm1hdGNoKC9bISU8Pj1cXCtcXC1cXCpcXC9dL2kpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpc0luc2lkZUlkZW50aWZpZXJPckFycmF5RGVzY3JpcHRvcih0OiBzdHJpbmcpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHQudG9Mb2NhbGVMb3dlckNhc2UoKS5tYXRjaCgvW2EtejAtOcOkw7bDvMOfXFxbXFxdXS9pKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufSJdfQ==